<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nothing Forever - Retro Pixel Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: linear-gradient(to bottom, #1a1a2e 0%, #16213e 100%);
        }
        #canvas {
            border: 4px solid #0f3460;
            box-shadow: 0 0 30px rgba(15, 52, 96, 0.8);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        #header {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            color: #00ff00;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: all;
            font-family: 'Courier New', monospace;
            border-bottom: 2px solid #00ff00;
        }
        #header h1 {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px #004400;
        }
        #header p {
            font-size: 11px;
            color: #00aa00;
        }
        #scene-info {
            text-align: right;
            color: #00ff00;
        }
        #dialogue-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 700px;
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #00ff00;
            border-radius: 0;
            padding: 15px;
            max-height: 150px;
            overflow-y: auto;
            pointer-events: all;
            font-family: 'Courier New', monospace;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            display: flex;
            gap: 10px;
        }
        #portrait-container {
            flex-shrink: 0;
            width: 80px;
            height: 80px;
            border: 3px solid #00ff00;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #portrait-container canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #dialogue-content {
            flex: 1;
            overflow-y: auto;
        }
        .dialogue-line {
            margin-bottom: 8px;
            animation: typewriter 0.3s steps(20);
            color: #ffffff;
            font-size: 14px;
            line-height: 1.4;
        }
        .dialogue-line .character {
            font-weight: bold;
            margin-right: 8px;
            text-shadow: 1px 1px #000;
        }
        @keyframes typewriter {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #controls {
            position: absolute;
            bottom: 190px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: all;
        }
        .control-btn {
            background: #00ff00;
            border: 3px solid #00aa00;
            width: 50px;
            height: 50px;
            color: #000;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.1s;
            font-size: 20px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            box-shadow: 0 4px 0 #004400;
        }
        .control-btn:hover {
            background: #00ff88;
            transform: translateY(-2px);
        }
        .control-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #004400;
        }
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #status {
            position: absolute;
            bottom: 190px;
            right: 20px;
            color: #00ff00;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border: 2px solid #00ff00;
            pointer-events: all;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        #location-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 4px solid #00ff00;
            padding: 30px 50px;
            text-align: center;
            color: #00ff00;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.5);
        }
        #location-banner h2 {
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 3px 3px #004400;
        }
        #location-banner p {
            font-size: 14px;
            color: #00aa00;
        }
        .generating {
            text-align: center;
            color: #00ff00;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="canvas"></canvas>
    </div>
    <div id="ui-overlay">
        <div id="header">
            <div>
                <h1>◆ NOTHING FOREVER ◆</h1>
                <p>16-BIT SITCOM GENERATOR</p>
            </div>
            <div id="scene-info">
                <div style="font-size: 13px;">SCENE: <span id="scene-count">00</span></div>
                <div style="font-size: 11px; color: #00aa00;" id="location-name">READY</div>
            </div>
        </div>
        
        <div id="location-banner">
            <h2 id="banner-title"></h2>
            <p id="banner-desc"></p>
        </div>
        
        <div id="dialogue-box">
            <div id="portrait-container">
                <canvas id="portrait-canvas" width="64" height="64"></canvas>
            </div>
            <div id="dialogue-content">
                <div id="dialogue-lines">
                    <p style="color: #00ff00; text-align: center;">▶ PRESS START TO BEGIN ◀</p>
                </div>
            </div>
        </div>
        
        <div id="controls">
            <button class="control-btn" id="play-btn">▶</button>
            <button class="control-btn" id="pause-btn" style="display: none;">❚❚</button>
            <button class="control-btn" id="skip-btn">⏩</button>
        </div>
        
        <div id="status">◼ PAUSED</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const portraitCanvas = document.getElementById('portrait-canvas');
        const portraitCtx = portraitCanvas.getContext('2d');
        
        // Canvas settings
        const SCALE = 3;
        const TILE_SIZE = 16;
        const CANVAS_WIDTH = 320;
        const CANVAS_HEIGHT = 240;
        const CHAR_SIZE = 16;
        
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        canvas.style.width = (CANVAS_WIDTH * SCALE) + 'px';
        canvas.style.height = (CANVAS_HEIGHT * SCALE) + 'px';
        
        ctx.imageSmoothingEnabled = false;
        portraitCtx.imageSmoothingEnabled = false;

        // Character data with voice properties
        const characters = {
            'Larry': { 
                color: '#4A90E2',
                hairColor: '#654321',
                skinColor: '#FFE0BD',
                shirtColor: '#2E5C8A',
                personality: 'Neurotic, observant, finds problems in everything',
                voicePitch: 0.8,
                voiceSpeed: 140,
                hasGlasses: true,
                hairStyle: 'receding'
            },
            'Janet': { 
                color: '#E24A4A',
                hairColor: '#1A1A1A',
                skinColor: '#C89664',
                shirtColor: '#C41E3A',
                personality: 'Sarcastic, intelligent, voice of reason',
                voicePitch: 1.2,
                voiceSpeed: 180,
                hasGlasses: false,
                hairStyle: 'curly'
            },
            'Mike': { 
                color: '#4AE290',
                hairColor: '#8B4513',
                skinColor: '#FFD7B5',
                shirtColor: '#5A8F4A',
                personality: 'Confident but clueless, schemes constantly',
                voicePitch: 1.0,
                voiceSpeed: 200,
                hasGlasses: false,
                hairStyle: 'wavy'
            }
        };

        const locations = [
            { 
                name: "APARTMENT", 
                description: "Jerry's cluttered apartment",
                floorColor: '#8B7355',
                wallColor: '#A89080',
                furnitureColor: '#654321',
                musicKey: 'apartment'
            },
            { 
                name: "COFFEE SHOP", 
                description: "Monk's Café",
                floorColor: '#6B5447',
                wallColor: '#8B7968',
                furnitureColor: '#5D4E37',
                musicKey: 'coffee'
            },
            { 
                name: "HALLWAY", 
                description: "Building corridor",
                floorColor: '#7A8B99',
                wallColor: '#9FAFBF',
                furnitureColor: '#5C6B7A',
                musicKey: 'hallway'
            },
            { 
                name: "STREET", 
                description: "New York sidewalk",
                floorColor: '#696969',
                wallColor: '#4A4A4A',
                furnitureColor: '#2F4F4F',
                musicKey: 'street'
            }
        ];

        // Music tracks for each location (15 second loops)
        const musicTracks = {
            apartment: [
                {note: 523.25, duration: 0.4}, {note: 587.33, duration: 0.4},
                {note: 659.25, duration: 0.4}, {note: 698.46, duration: 0.4},
                {note: 783.99, duration: 0.8}, {note: 698.46, duration: 0.4},
                {note: 659.25, duration: 0.4}, {note: 587.33, duration: 0.8},
                {note: 523.25, duration: 0.4}, {note: 493.88, duration: 0.4},
                {note: 440.00, duration: 0.8}, {note: 493.88, duration: 0.4},
                {note: 523.25, duration: 1.2}
            ],
            coffee: [
                {note: 392.00, duration: 0.3}, {note: 440.00, duration: 0.3},
                {note: 493.88, duration: 0.3}, {note: 523.25, duration: 0.6},
                {note: 493.88, duration: 0.3}, {note: 440.00, duration: 0.3},
                {note: 392.00, duration: 0.6}, {note: 329.63, duration: 0.3},
                {note: 349.23, duration: 0.3}, {note: 392.00, duration: 0.6},
                {note: 440.00, duration: 0.3}, {note: 493.88, duration: 0.3},
                {note: 523.25, duration: 0.9}
            ],
            hallway: [
                {note: 261.63, duration: 0.5}, {note: 293.66, duration: 0.5},
                {note: 329.63, duration: 0.5}, {note: 349.23, duration: 0.5},
                {note: 392.00, duration: 1.0}, {note: 349.23, duration: 0.5},
                {note: 329.63, duration: 0.5}, {note: 293.66, duration: 1.0},
                {note: 261.63, duration: 1.0}
            ],
            street: [
                {note: 659.25, duration: 0.3}, {note: 587.33, duration: 0.3},
                {note: 523.25, duration: 0.3}, {note: 493.88, duration: 0.3},
                {note: 440.00, duration: 0.6}, {note: 493.88, duration: 0.3},
                {note: 523.25, duration: 0.3}, {note: 587.33, duration: 0.6},
                {note: 659.25, duration: 0.3}, {note: 698.46, duration: 0.3},
                {note: 783.99, duration: 0.9}
            ]
        };

        const sceneTypes = [
            "Larry complains about a minor inconvenience",
            "The group debates a ridiculous topic",
            "Someone has a scheme that will obviously backfire",
            "A mundane situation spirals out of control",
            "Two characters have an argument while one watches",
            "Someone discovers something absurd",
            "A character tries to explain something complicated"
        ];

        // State
        let isPlaying = false;
        let isGenerating = false;
        let sceneCount = 0;
        let currentLocation = locations[0];
        let animationFrame = 0;
        let speakingCharacter = null;
        let speakingTimer = 0;
        
        // Audio
        let audioContext = null;
        let backgroundMusic = null;
        let currentVoiceInterval = null;
        let currentMusicTrack = 'apartment';
        let movementInterval = null;
        
        // Character states
        const characterStates = {
            'Larry': { x: 80, y: 140, targetX: 80, targetY: 140, facing: 'down', action: 'idle' },
            'Janet': { x: 160, y: 140, targetX: 160, targetY: 140, facing: 'down', action: 'idle' },
            'Mike': { x: 240, y: 140, targetX: 240, targetY: 140, facing: 'down', action: 'idle' }
        };

        // Audio functions
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }
        
        function playBackgroundMusic() {
            if (!audioContext) return;
            
            stopBackgroundMusic();
            
            const melody = musicTracks[currentMusicTrack] || musicTracks.apartment;
            let currentNote = 0;
            
            function playNote() {
                if (!isPlaying || !audioContext) return;
                
                const note = melody[currentNote % melody.length];
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'square';
                oscillator.frequency.value = note.note;
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.03, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + note.duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + note.duration);
                
                currentNote++;
                backgroundMusic = setTimeout(playNote, note.duration * 1000);
            }
            
            playNote();
        }
        
        function stopBackgroundMusic() {
            if (backgroundMusic) {
                clearTimeout(backgroundMusic);
                backgroundMusic = null;
            }
        }
        
        function playCharacterVoice(characterName, text) {
            if (!audioContext) return;
            if (currentVoiceInterval) {
                clearInterval(currentVoiceInterval);
            }
            
            const char = characters[characterName];
            let charIndex = 0;
            const textLength = text.replace(/\s/g, '').length;
            
            function makeSound() {
                if (charIndex >= textLength || speakingCharacter !== characterName) {
                    clearInterval(currentVoiceInterval);
                    return;
                }
                
                while (charIndex < textLength && text[charIndex] === ' ') {
                    charIndex++;
                }
                
                if (charIndex >= textLength) return;
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.type = 'triangle';
                
                const baseFreq = 200 * char.voicePitch;
                const variation = (Math.random() - 0.5) * 50;
                oscillator.frequency.value = baseFreq + variation;
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.08, audioContext.currentTime + 0.005);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.08);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.08);
                
                charIndex++;
            }
            
            makeSound();
            currentVoiceInterval = setInterval(makeSound, char.voiceSpeed);
        }
        
        function stopCharacterVoice() {
            if (currentVoiceInterval) {
                clearInterval(currentVoiceInterval);
                currentVoiceInterval = null;
            }
        }

        function setCharacterSpeaking(name, text) {
            speakingCharacter = name;
            speakingTimer = 60;
            playCharacterVoice(name, text);
            drawPortrait(name);
        }
        
        function stopSpeaking() {
            speakingCharacter = null;
            stopCharacterVoice();
        }

        // Draw character portrait
        function drawPortrait(name) {
            const data = characters[name];
            portraitCtx.clearRect(0, 0, 64, 64);
            
            portraitCtx.save();
            portraitCtx.translate(32, 32);
            
            // Head
            portraitCtx.fillStyle = data.skinColor;
            portraitCtx.fillRect(-12, -16, 24, 24);
            
            const skinLight = lightenColor(data.skinColor, 15);
            const skinDark = darkenColor(data.skinColor, 20);
            portraitCtx.fillStyle = skinLight;
            portraitCtx.fillRect(-12, -16, 8, 24);
            portraitCtx.fillStyle = skinDark;
            portraitCtx.fillRect(6, -16, 6, 24);
            
            // Hair based on style
            portraitCtx.fillStyle = data.hairColor;
            if (data.hairStyle === 'receding') {
                // Larry - receding hairline
                portraitCtx.fillRect(-10, -20, 20, 6);
                portraitCtx.fillRect(-12, -18, 2, 8);
                portraitCtx.fillRect(10, -18, 2, 8);
            } else if (data.hairStyle === 'curly') {
                // Janet - big curly hair
                portraitCtx.fillRect(-14, -22, 28, 8);
                portraitCtx.fillRect(-16, -18, 4, 12);
                portraitCtx.fillRect(12, -18, 4, 12);
                // Add texture
                const hairLight = lightenColor(data.hairColor, 30);
                portraitCtx.fillStyle = hairLight;
                for (let i = 0; i < 5; i++) {
                    portraitCtx.fillRect(-12 + i * 5, -20, 2, 2);
                }
            } else {
                // Mike - wavy
                portraitCtx.fillRect(-12, -20, 24, 6);
                portraitCtx.fillRect(-14, -18, 2, 6);
                portraitCtx.fillRect(12, -18, 2, 6);
            }
            
            // Ears
            portraitCtx.fillStyle = data.skinColor;
            portraitCtx.fillRect(-14, -8, 2, 6);
            portraitCtx.fillRect(12, -8, 2, 6);
            
            // Glasses for Larry
            if (data.hasGlasses) {
                portraitCtx.strokeStyle = '#333333';
                portraitCtx.lineWidth = 1;
                portraitCtx.strokeRect(-10, -10, 6, 6);
                portraitCtx.strokeRect(4, -10, 6, 6);
                portraitCtx.fillRect(-4, -7, 4, 1);
            }
            
            // Eyes
            portraitCtx.fillStyle = '#FFFFFF';
            portraitCtx.fillRect(-8, -10, 4, 4);
            portraitCtx.fillRect(4, -10, 4, 4);
            portraitCtx.fillStyle = '#000000';
            portraitCtx.fillRect(-6, -8, 2, 2);
            portraitCtx.fillRect(6, -8, 2, 2);
            
            // Eyebrows
            portraitCtx.fillStyle = darkenColor(data.hairColor, 40);
            portraitCtx.fillRect(-9, -12, 5, 1);
            portraitCtx.fillRect(4, -12, 5, 1);
            
            // Nose
            portraitCtx.fillStyle = skinDark;
            portraitCtx.fillRect(0, -4, 2, 4);
            portraitCtx.fillRect(2, -2, 2, 2);
            
            // Mouth
            portraitCtx.fillStyle = '#000000';
            portraitCtx.fillRect(-3, 2, 6, 2);
            
            // Shirt
            portraitCtx.fillStyle = data.shirtColor;
            portraitCtx.fillRect(-14, 8, 28, 24);
            const shirtLight = lightenColor(data.shirtColor, 30);
            const shirtDark = darkenColor(data.shirtColor, 30);
            portraitCtx.fillStyle = shirtLight;
            portraitCtx.fillRect(-14, 8, 8, 24);
            portraitCtx.fillStyle = shirtDark;
            portraitCtx.fillRect(8, 8, 6, 24);
            
            portraitCtx.restore();
        }

        // Helper functions
        function lightenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }
        
        function darkenColor(color, percent) {
            const num = parseInt(color.replace("#",""), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return "#" + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // Draw character
        function drawCharacter(name, isSpeaking) {
            const state = characterStates[name];
            const data = characters[name];
            const x = state.x;
            const y = state.y;
            
            const speed = 0.8;
            if (Math.abs(state.x - state.targetX) > 1) {
                state.x += (state.targetX - state.x) * 0.1;
                state.action = 'walking';
            } else if (Math.abs(state.y - state.targetY) > 1) {
                state.y += (state.targetY - state.y) * 0.1;
                state.action = 'walking';
            } else {
                state.action = state.action === 'walking' ? 'idle' : state.action;
            }
            
            const frame = state.action === 'walking' ? Math.floor(animationFrame / 10) % 4 : 0;
            const bounce = isSpeaking ? Math.sin(animationFrame * 0.2) * 1 : 0;
            
            ctx.save();
            ctx.translate(x, y - bounce);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 7, 6, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            let leftLegOffset = 0, rightLegOffset = 0;
            if (state.action === 'walking') {
                leftLegOffset = frame === 1 || frame === 2 ? 1 : 0;
                rightLegOffset = frame === 0 || frame === 3 ? 1 : 0;
            }
            
            ctx.fillStyle = '#1A252F';
            ctx.fillRect(-3 + leftLegOffset, 2, 2, 5);
            ctx.fillRect(1 + rightLegOffset, 2, 2, 5);
            ctx.fillStyle = '#2C3E50';
            ctx.fillRect(-3 + leftLegOffset, 2, 1, 5);
            ctx.fillRect(1 + rightLegOffset, 2, 1, 5);
            
            ctx.fillStyle = '#000000';
            ctx.fillRect(-4 + leftLegOffset, 6, 3, 2);
            ctx.fillRect(1 + rightLegOffset, 6, 3, 2);
            ctx.fillStyle = '#333333';
            ctx.fillRect(-4 + leftLegOffset, 6, 1, 1);
            ctx.fillRect(1 + rightLegOffset, 6, 1, 1);
            
            ctx.fillStyle = data.shirtColor;
            ctx.fillRect(-4, -4, 8, 6);
            
            const shirtLight = lightenColor(data.shirtColor, 30);
            const shirtDark = darkenColor(data.shirtColor, 30);
            ctx.fillStyle = shirtLight;
            ctx.fillRect(-4, -4, 2, 6);
            ctx.fillStyle = shirtDark;
            ctx.fillRect(2, -4, 2, 6);
            
            ctx.fillStyle = darkenColor(data.shirtColor, 50);
            ctx.fillRect(-2, -4, 4, 1);
            
            const armSwing = state.action === 'walking' ? Math.sin(animationFrame * 0.3) * 2 : 0;
            const speakWave = isSpeaking ? Math.sin(animationFrame * 0.3) : 0;
            
            if (isSpeaking || state.action === 'walking') {
                ctx.fillStyle = data.shirtColor;
                ctx.fillRect(-6, -2 + (isSpeaking ? speakWave : -armSwing), 2, 4);
                ctx.fillStyle = shirtDark;
                ctx.fillRect(-5, -2 + (isSpeaking ? speakWave : -armSwing), 1, 4);
                
                ctx.fillStyle = data.shirtColor;
                ctx.fillRect(4, -2 + (isSpeaking ? -speakWave : armSwing), 2, 4);
                ctx.fillStyle = shirtLight;
                ctx.fillRect(4, -2 + (isSpeaking ? -speakWave : armSwing), 1, 4);
            } else {
                ctx.fillStyle = data.shirtColor;
                ctx.fillRect(-6, -2, 2, 4);
                ctx.fillRect(4, -2, 2, 4);
                ctx.fillStyle = shirtDark;
                ctx.fillRect(-5, -2, 1, 4);
                ctx.fillStyle = shirtLight;
                ctx.fillRect(4, -2, 1, 4);
            }
            
            const handOffsetLeft = isSpeaking ? speakWave : (state.action === 'walking' ? -armSwing : 0);
            const handOffsetRight = isSpeaking ? -speakWave : (state.action === 'walking' ? armSwing : 0);
            
            ctx.fillStyle = data.skinColor;
            ctx.fillRect(-6, 2 + handOffsetLeft, 2, 2);
            ctx.fillRect(4, 2 + handOffsetRight, 2, 2);
            ctx.fillStyle = darkenColor(data.skinColor, 20);
            ctx.fillRect(-5, 2 + handOffsetLeft, 1, 2);
            ctx.fillRect(5, 2 + handOffsetRight, 1, 2);
            
            ctx.fillStyle = data.skinColor;
            ctx.fillRect(-1, -5, 2, 2);
            ctx.fillStyle = darkenColor(data.skinColor, 15);
            ctx.fillRect(0, -5, 1, 2);
            
            ctx.fillStyle = data.skinColor;
            ctx.fillRect(-4, -11, 8, 7);
            const skinLight = lightenColor(data.skinColor, 15);
            const skinDark = darkenColor(data.skinColor, 20);
            ctx.fillStyle = skinLight;
            ctx.fillRect(-4, -11, 3, 7);
            ctx.fillStyle = skinDark;
            ctx.fillRect(2, -11, 2, 7);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            ctx.clearRect(-4, -11, 1, 1);
            ctx.clearRect(3, -11, 1, 1);
            ctx.clearRect(-4, -5, 1, 1);
            ctx.clearRect(3, -5, 1, 1);
            
            // Hair based on style
            if (data.hairStyle === 'receding') {
                // Larry - balding/receding
                ctx.fillRect(-3, -13, 6, 3);
                ctx.fillRect(-5, -12, 2, 4);
                ctx.fillRect(3, -12, 2, 4);
            } else if (data.hairStyle === 'curly') {
                // Janet - big curly hair
                ctx.fillRect(-5, -13, 10, 4);
                ctx.fillRect(-6, -12, 2, 6);
                ctx.fillRect(4, -12, 2, 6);
                const hairLight = lightenColor(data.hairColor, 40);
                ctx.fillStyle = hairLight;
                ctx.fillRect(-4, -13, 2, 1);
                ctx.fillRect(-1, -12, 2, 1);
                ctx.fillRect(2, -13, 2, 1);
            } else {
                // Mike - wavy
                ctx.fillRect(-4, -13, 8, 3);
                ctx.fillRect(-5, -12, 1, 2);
                ctx.fillRect(4, -12, 1, 2);
                const hairLight = lightenColor(data.hairColor, 40);
                ctx.fillStyle = hairLight;
                ctx.fillRect(-3, -13, 2, 1);
                ctx.fillRect(-2, -12, 1, 1);
            }
            
            ctx.fillStyle = data.skinColor;
            ctx.fillRect(-5, -8, 1, 2);
            ctx.fillRect(4, -8, 1, 2);
            ctx.fillStyle = skinDark;
            ctx.fillRect(-5, -7, 1, 1);
            ctx.fillRect(4, -7, 1, 1);
            
            const eyeBlink = isSpeaking && Math.floor(animationFrame / 40) % 8 === 0;
            ctx.fillStyle = '#FFFFFF';
            if (!eyeBlink) {
                ctx.fillRect(-3, -9, 2, 2);
                ctx.fillRect(1, -9, 2, 2);
                ctx.fillStyle = '#000000';
                ctx.fillRect(-2, -8, 1, 1);
                ctx.fillRect(2, -8, 1, 1);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(-3, -9, 1, 1);
                ctx.fillRect(1, -9, 1, 1);
            } else {
                ctx.fillStyle = '#000000';
                ctx.fillRect(-3, -8, 2, 1);
                ctx.fillRect(1, -8, 2, 1);
            }
            
            ctx.fillStyle = darkenColor(data.hairColor, 40);
            ctx.fillRect(-3, -10, 2, 1);
            ctx.fillRect(1, -10, 2, 1);
            
            ctx.fillStyle = skinDark;
            ctx.fillRect(0, -7, 1, 2);
            ctx.fillRect(1, -6, 1, 1);
            
            if (isSpeaking && Math.floor(animationFrame / 15) % 2 === 0) {
                ctx.fillStyle = '#000000';
                ctx.fillRect(-1, -5, 2, 1);
                ctx.fillStyle = '#8B4545';
                ctx.fillRect(-1, -4, 2, 1);
            } else {
                ctx.fillStyle = '#000000';
                ctx.fillRect(-1, -5, 2, 1);
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x - 15, y + 10, 30, 10);
            ctx.fillStyle = data.color;
            ctx.font = 'bold 7px monospace';
            ctx.textAlign = 'center';
            // Removed name label text
            
            ctx.restore();
        }

        // Draw environment with detail
        function drawEnvironment() {
            const gradient = ctx.createLinearGradient(0, 0, 0, 100);
            gradient.addColorStop(0, '#5C7A9E');
            gradient.addColorStop(1, '#8BA4BF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, 100);
            
            ctx.fillStyle = currentLocation.wallColor;
            ctx.fillRect(0, 100, CANVAS_WIDTH, 60);
            
            ctx.fillStyle = darkenColor(currentLocation.wallColor, 10);
            for (let x = 0; x < CANVAS_WIDTH; x += 32) {
                ctx.fillRect(x, 100, 2, 60);
            }
            ctx.fillRect(0, 130, CANVAS_WIDTH, 2);
            
            ctx.fillStyle = currentLocation.floorColor;
            ctx.fillRect(0, 160, CANVAS_WIDTH, CANVAS_HEIGHT - 160);
            
            const floorLight = lightenColor(currentLocation.floorColor, 10);
            const floorDark = darkenColor(currentLocation.floorColor, 15);
            
            for (let y = 160; y < CANVAS_HEIGHT; y += TILE_SIZE) {
                for (let x = 0; x < CANVAS_WIDTH; x += TILE_SIZE) {
                    ctx.fillStyle = floorDark;
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = currentLocation.floorColor;
                    ctx.fillRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                    ctx.fillStyle = floorLight;
                    ctx.fillRect(x + 2, y + 2, TILE_SIZE - 6, TILE_SIZE - 6);
                }
            }
            
            if (currentLocation.name === "APARTMENT") {
                const couchDark = darkenColor('#8B0000', 30);
                const couchLight = lightenColor('#8B0000', 20);
                
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(15, 125, 60, 8);
                ctx.fillStyle = couchDark;
                ctx.fillRect(15, 125, 60, 2);
                ctx.fillStyle = couchLight;
                ctx.fillRect(15, 131, 60, 2);
                
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(15, 133, 60, 25);
                ctx.fillStyle = couchDark;
                ctx.fillRect(15, 133, 3, 25);
                ctx.fillRect(72, 133, 3, 25);
                ctx.fillStyle = couchLight;
                ctx.fillRect(18, 133, 3, 25);
                
                ctx.fillStyle = couchDark;
                ctx.fillRect(25, 138, 18, 3);
                ctx.fillRect(50, 138, 18, 3);
                
                ctx.fillStyle = '#3E2723';
                ctx.fillRect(240, 130, 50, 25);
                ctx.fillStyle = darkenColor('#3E2723', 20);
                ctx.fillRect(240, 130, 2, 25);
                ctx.fillRect(288, 130, 2, 25);
                
                ctx.fillStyle = '#1C1C1C';
                ctx.fillRect(245, 110, 40, 32);
                ctx.fillStyle = '#2E2E2E';
                ctx.fillRect(247, 112, 36, 28);
                ctx.fillStyle = '#4A6FA5';
                ctx.fillRect(249, 114, 32, 24);
                ctx.fillStyle = '#7BA3D0';
                ctx.fillRect(249, 114, 16, 12);
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(80, 165, 80, 60);
                ctx.fillStyle = darkenColor('#8B4513', 20);
                ctx.fillRect(82, 167, 76, 56);
                ctx.fillStyle = lightenColor('#8B4513', 30);
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(90 + i * 20, 175, 15, 2);
                }
                
            } else if (currentLocation.name === "COFFEE SHOP") {
                ctx.fillStyle = '#654321';
                ctx.fillRect(10, 120, 80, 35);
                ctx.fillStyle = lightenColor('#654321', 20);
                ctx.fillRect(10, 120, 80, 3);
                ctx.fillStyle = darkenColor('#654321', 25);
                ctx.fillRect(10, 152, 80, 3);
                
                ctx.fillStyle = darkenColor('#654321', 15);
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(15 + i * 18, 125, 2, 27);
                }
                
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(20, 110, 20, 25);
                ctx.fillStyle = '#A0A0A0';
                ctx.fillRect(22, 112, 16, 20);
                ctx.fillStyle = '#FF6B00';
                ctx.fillRect(28, 118, 4, 4);
                
                ctx.fillStyle = currentLocation.furnitureColor;
                ctx.fillRect(130, 145, 60, 35);
                ctx.fillStyle = lightenColor(currentLocation.furnitureColor, 20);
                ctx.fillRect(130, 145, 60, 3);
                ctx.fillStyle = darkenColor(currentLocation.furnitureColor, 20);
                ctx.fillRect(130, 177, 60, 3);
                
                ctx.fillStyle = darkenColor(currentLocation.furnitureColor, 30);
                ctx.fillRect(138, 165, 6, 15);
                ctx.fillRect(176, 165, 6, 15);
            } else if (currentLocation.name === "STREET") {
                for (let i = 0; i < 3; i++) {
                    const x = 15 + i * 80;
                    const h = 40 + Math.random() * 20;
                    ctx.fillStyle = '#2C2C2C';
                    ctx.fillRect(x, 130 - h, 35, h);
                    
                    for (let j = 0; j < 3; j++) {
                        const lit = Math.random() > 0.3;
                        ctx.fillStyle = lit ? '#FFFF00' : '#444444';
                        ctx.fillRect(x + 5, 95 + j * 12, 8, 8);
                    }
                }
                
                ctx.fillStyle = '#4A4A4A';
                ctx.fillRect(0, 155, CANVAS_WIDTH, 5);
                ctx.fillStyle = '#2A2A2A';
                ctx.fillRect(0, 157, CANVAS_WIDTH, 1);
            }
        }

        function render() {
            animationFrame++;
            
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            drawEnvironment();
            
            if (speakingCharacter && speakingTimer > 0) {
                speakingTimer--;
            } else if (speakingTimer === 0) {
                speakingCharacter = null;
            }
            
            // Random idle movement every few seconds
            if (isPlaying && animationFrame % 180 === 0) {
                Object.keys(characters).forEach(name => {
                    if (Math.random() > 0.6) {
                        const actions = ['walk_left', 'walk_right', 'pace'];
                        const action = actions[Math.floor(Math.random() * actions.length)];
                        performCharacterAction(name, action);
                    }
                });
            }
            
            Object.keys(characters).forEach(name => {
                drawCharacter(name, speakingCharacter === name);
            });
            
            requestAnimationFrame(render);
        }
        
        render();

        // Position characters
        function positionCharactersForLocation() {
            if (currentLocation.name === "APARTMENT") {
                characterStates['Larry'].targetX = 45;
                characterStates['Larry'].targetY = 145;
                characterStates['Janet'].targetX = 160;
                characterStates['Janet'].targetY = 165;
                characterStates['Mike'].targetX = 270;
                characterStates['Mike'].targetY = 150;
            } else if (currentLocation.name === "COFFEE SHOP") {
                characterStates['Larry'].targetX = 120;
                characterStates['Larry'].targetY = 165;
                characterStates['Janet'].targetX = 160;
                characterStates['Janet'].targetY = 150;
                characterStates['Mike'].targetX = 200;
                characterStates['Mike'].targetY = 165;
            } else if (currentLocation.name === "STREET") {
                characterStates['Larry'].targetX = 80;
                characterStates['Larry'].targetY = 170;
                characterStates['Janet'].targetX = 160;
                characterStates['Janet'].targetY = 165;
                characterStates['Mike'].targetX = 240;
                characterStates['Mike'].targetY = 170;
            } else {
                characterStates['Larry'].targetX = 80;
                characterStates['Larry'].targetY = 170;
                characterStates['Janet'].targetX = 160;
                characterStates['Janet'].targetY = 170;
                characterStates['Mike'].targetX = 240;
                characterStates['Mike'].targetY = 170;
            }
        }
        
        function performCharacterAction(name, action) {
            const state = characterStates[name];
            
            switch(action) {
                case 'walk_left':
                    state.targetX = Math.max(40, state.targetX - 40);
                    break;
                case 'walk_right':
                    state.targetX = Math.min(280, state.targetX + 40);
                    break;
                case 'pace':
                    setTimeout(() => {
                        state.targetX = state.x + (Math.random() > 0.5 ? 30 : -30);
                    }, 1000);
                    break;
                case 'approach':
                    state.targetX = 160 + (Math.random() - 0.5) * 40;
                    state.targetY = 160 + (Math.random() - 0.5) * 20;
                    break;
            }
        }

        const playBtn = document.getElementById('play-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const skipBtn = document.getElementById('skip-btn');
        const statusEl = document.getElementById('status');
        const sceneCountEl = document.getElementById('scene-count');
        const locationNameEl = document.getElementById('location-name');
        const dialogueLinesEl = document.getElementById('dialogue-lines');
        const locationBanner = document.getElementById('location-banner');
        const bannerTitle = document.getElementById('banner-title');
        const bannerDesc = document.getElementById('banner-desc');

        async function generateScene() {
            if (isGenerating) return;
            
            isGenerating = true;
            skipBtn.disabled = true;
            
            const location = locations[Math.floor(Math.random() * locations.length)];
            const sceneType = sceneTypes[Math.floor(Math.random() * sceneTypes.length)];
            
            sceneCount++;
            sceneCountEl.textContent = sceneCount.toString().padStart(2, '0');
            locationNameEl.textContent = location.name;
            currentLocation = location;
            
            // Change music for new location
            currentMusicTrack = location.musicKey;
            if (isPlaying && audioContext) {
                stopBackgroundMusic();
                playBackgroundMusic();
            }
            
            bannerTitle.textContent = location.name;
            bannerDesc.textContent = location.description;
            locationBanner.style.opacity = '1';
            setTimeout(() => {
                locationBanner.style.opacity = '0';
            }, 3000);
            
            dialogueLinesEl.innerHTML = '<p class="generating">▶ GENERATING SCENE...</p>';
            
            const characterList = Object.entries(characters)
                .map(([name, data]) => `${name} (${data.personality})`)
                .join(', ');

            const prompt = `You are writing a Seinfeld-style sitcom scene.

Characters: ${characterList}
Location: ${location.name} - ${location.description}
Scene type: ${sceneType}

Write a MEDIUM-LENGTH comedic scene (8-12 exchanges of dialogue). Format EXACTLY as:
LARRY: dialogue text here
JANET: dialogue text here
MIKE: dialogue text here

IMPORTANT: 
- Use ONLY these character names (LARRY, JANET, MIKE) in all caps
- Do not introduce other characters
- Make the dialogue substantial - each line should be 1-3 sentences
- Keep it observational, absurd, and true to character personalities
- Make it funny and conversational with good back-and-forth
- Build to a comedic peak or realization`;

            try {
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 1000,
                        messages: [{ role: 'user', content: prompt }]
                    })
                });

                if (response.status === 429) {
                    const retryAfter = response.headers.get('retry-after') || 60;
                    dialogueLinesEl.innerHTML = `<p style="color: #ffaa00; text-align: center;">⚠ RATE LIMIT! WAITING ${retryAfter}s...</p>`;
                    await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
                    
                    if (isPlaying) {
                        isGenerating = false;
                        skipBtn.disabled = false;
                        return generateScene();
                    } else {
                        isGenerating = false;
                        skipBtn.disabled = false;
                        return;
                    }
                }

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const data = await response.json();
                const sceneText = data.content[0].text;
                
                dialogueLinesEl.innerHTML = '';
                await parseAndDisplayDialogue(sceneText);
                
            } catch (error) {
                console.error('Error generating scene:', error);
                dialogueLinesEl.innerHTML = `<p style="color: #ff6b6b; text-align: center;">ERROR: ${error.message}</p>`;
                isGenerating = false;
                skipBtn.disabled = false;
                return;
            }
        }

        async function parseAndDisplayDialogue(sceneText) {
            const lines = sceneText.split('\n').filter(line => line.trim());
            const dialogue = [];
            
            const pattern = /^([A-Za-z]+):\s*(.+)$/;
            
            for (const line of lines) {
                const match = line.match(pattern);
                if (match) {
                    const charName = match[1].toUpperCase();
                    const text = match[2].trim();
                    
                    let character;
                    if (charName === 'LARRY') character = 'Larry';
                    else if (charName === 'JANET') character = 'Janet';
                    else if (charName === 'MIKE') character = 'Mike';
                    else {
                        character = 'Larry';
                    }
                    
                    dialogue.push({ character, text, color: characters[character].color });
                }
            }
            
            positionCharactersForLocation();
            
            const actions = ['pace', 'approach', 'walk_left', 'walk_right'];
            
            for (let i = 0; i < dialogue.length; i++) {
                if (!isPlaying) return;
                
                const baseDelay = 2500;
                const wordCount = dialogue[i].text.split(' ').length;
                const delay = baseDelay + Math.min(wordCount * 100, 2000);
                
                await new Promise(resolve => setTimeout(resolve, delay));
                
                const line = dialogue[i];
                const lineEl = document.createElement('div');
                lineEl.className = 'dialogue-line';
                lineEl.innerHTML = `
                    <span class="character" style="color: ${line.color};">${line.character}:</span>
                    <span class="text">${line.text}</span>
                `;
                dialogueLinesEl.appendChild(lineEl);
                
                setCharacterSpeaking(line.character, line.text);
                
                if (Math.random() > 0.7 && i > 0) {
                    const randomAction = actions[Math.floor(Math.random() * actions.length)];
                    performCharacterAction(line.character, randomAction);
                }
                
                if (Math.random() > 0.8) {
                    const otherChars = Object.keys(characters).filter(n => n !== line.character);
                    const reactor = otherChars[Math.floor(Math.random() * otherChars.length)];
                    performCharacterAction(reactor, 'approach');
                }
                
                lineEl.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
            
            stopSpeaking();
            
            if (isPlaying) {
                await new Promise(resolve => setTimeout(resolve, 10000));
                
                if (isPlaying) {
                    isGenerating = false;
                    skipBtn.disabled = false;
                    generateScene();
                } else {
                    isGenerating = false;
                    skipBtn.disabled = false;
                }
            } else {
                isGenerating = false;
                skipBtn.disabled = false;
            }
        }

        playBtn.addEventListener('click', () => {
            isPlaying = true;
            playBtn.style.display = 'none';
            pauseBtn.style.display = 'flex';
            statusEl.textContent = '▶ LIVE';
            
            initAudio();
            playBackgroundMusic();
            
            if (sceneCount === 0) {
                generateScene();
            }
        });

        pauseBtn.addEventListener('click', () => {
            isPlaying = false;
            pauseBtn.style.display = 'none';
            playBtn.style.display = 'flex';
            statusEl.textContent = '◼ PAUSED';
            
            stopBackgroundMusic();
            stopCharacterVoice();
        });

        skipBtn.addEventListener('click', () => {
            if (!isGenerating) {
                stopCharacterVoice();
                generateScene();
            }
        });
    </script>
</body>
</html>
                